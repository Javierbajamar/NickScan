import asynciofrom typing import Dictimport aiohttpSITES = {    "GitHub": {        "url": "https://github.com/{}",        "error_msg": "Not Found"    },    "Twitter": {        "url": "https://twitter.com/{}",        "error_msg": "This account doesn't exist"    },    "Instagram": {        "url": "https://www.instagram.com/{}",        "error_msg": "Sorry, this page isn't available"    },    "Reddit": {        "url": "https://www.reddit.com/user/{}",        "error_msg": "Sorry, nobody on Reddit goes by that name"    },    "YouTube": {        "url": "https://www.youtube.com/@{}",        "error_msg": "This page isn't available"    },    "TikTok": {        "url": "https://www.tiktok.com/@{}",        "error_msg": "Couldn't find this account"    },    "Twitch": {        "url": "https://www.twitch.tv/{}",        "error_msg": "Sorry. Unless you've got a time machine"    },    "LinkedIn": {        "url": "https://www.linkedin.com/in/{}",        "error_msg": "Page not found"    }}HEADERS = {    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'}async def check_site(session: aiohttp.ClientSession, site: str, username: str, site_data: dict) -> tuple:    """    Verifica si un username existe en un sitio espec√≠fico.        Returns:        tuple: (site_name, found_status, url)               found_status puede ser: True, False, o None (error)    """    url = site_data["url"].format(username)    try:        async with session.get(url, timeout=aiohttp.ClientTimeout(total=10), allow_redirects=True) as response:            # Verificar status code            if response.status == 200:                # Leer el contenido para verificar mensajes de error                text = await response.text()                # Si encuentra el mensaje de error en el HTML, el usuario NO existe                if site_data["error_msg"].lower() in text.lower():                    return site, False, url                return site, True, url            elif response.status == 404:                return site, False, url            else:                # Otros c√≥digos de estado (403, 429, etc.)                return site, None, url    except asyncio.TimeoutError:        return site, None, url    except Exception as e:        return site, None, urlasync def scan_async(username: str) -> Dict[str, tuple]:    """    Escanea todos los sitios de forma as√≠ncrona.        Returns:        dict: {site_name: (found, url)}    """    results = {}    async with aiohttp.ClientSession(headers=HEADERS) as session:        # Crear todas las tareas        tasks = [            check_site(session, site, username, site_data)            for site, site_data in SITES.items()        ]        # Ejecutar todas las tareas en paralelo        responses = await asyncio.gather(*tasks)        # Procesar resultados        for site, found, url in responses:            results[site] = (found, url)    return resultsdef print_results(username: str, results: Dict[str, tuple]):    """Imprime los resultados de forma organizada."""    print(f"\n{'=' * 60}")    print(f"Resultados para: {username}")    print(f"{'=' * 60}\n")    found_accounts = []    not_found = []    errors = []    for site, (status, url) in results.items():        if status is True:            found_accounts.append((site, url))        elif status is False:            not_found.append(site)        else:            errors.append(site)    # Mostrar cuentas encontradas    if found_accounts:        print("‚úì ENCONTRADAS:")        print("-" * 60)        for site, url in found_accounts:            print(f"  {site:15} ‚Üí {url}")        print()    # Mostrar no encontradas    if not_found:        print("‚úó NO ENCONTRADAS:")        print("-" * 60)        for site in not_found:            print(f"  {site}")        print()    # Mostrar errores    if errors:        print("‚ö† ERROR/TIMEOUT:")        print("-" * 60)        for site in errors:            print(f"  {site} (no se pudo verificar)")        print()    # Resumen    print(f"{'=' * 60}")    print(f"Resumen: {len(found_accounts)} encontradas | {len(not_found)} no encontradas | {len(errors)} errores")    print(f"{'=' * 60}\n")def main():    """Funci√≥n principal del programa."""    print("\n" + "=" * 60)    print(" USERNAME SCANNER - B√∫squeda de perfiles en redes sociales")    print("=" * 60)    username = input("\nIntroduce el username a buscar: ").strip()    if not username:        print("‚ùå Error: Debes introducir un username v√°lido")        return    print(f"\nüîç Buscando '{username}' en {len(SITES)} plataformas...")    print("‚è≥ Por favor espera...\n")    # Ejecutar el escaneo as√≠ncrono    results = asyncio.run(scan_async(username))    # Mostrar resultados    print_results(username, results)if __name__ == "__main__":    try:        main()    except KeyboardInterrupt:        print("\n\n‚ùå B√∫squeda cancelada por el usuario.")    except Exception as e:        print(f"\n‚ùå Error inesperado: {e}")